#ifndef FILEINDEX_HPP
#define FILEINDEX_HPP
#define FILEINDEX_SORTBUFFERSIZE 64000000ULL
#define FILEINDEX_CACHELEVEL 8
#include <string>
#include <map>
#include <algorithm>
#include <stdio.h>
#include <string.h>
#include <iostream>

// IMPORTANT KEY et ITEM doivent être des types 'triviaux'
// i.e. entier, double, char ou structure et tableaux de ces types.
namespace fidx {
template <class ITEM,class KEY> struct Record {
			KEY key;
			ITEM value;
};

// fonction de comparaison
// à spécialiser si l'opérateur de comparaison n'est pas disponible
template <class ITEM, class KEY> int fileIndexComp(const void* a, const void* b) {
    Record<ITEM,KEY>* ga = (Record<ITEM,KEY>*) a;
    Record<ITEM,KEY>* gb = (Record<ITEM,KEY>*) b;
    if( ga->key < gb->key ) return -1; 
    else if( ga->key > gb->key ) return 1; 
    return 0; 
}


template<class ITEM, class KEY> class FileIndex {
	private:
		std::string filename;
		FILE * pFile;
		Record<ITEM, KEY> *buffer;
		unsigned long bufferCount;
		size_t recSize;
		size_t fileSize;
		std::map<size_t, Record<ITEM, KEY>> cache;
	public:
		FileIndex(std::string filename, bool replace) : filename(filename) {
            if(!replace)
                pFile = fopen (filename.c_str(),"r+");
            else pFile = NULL;
            buffer = NULL;
			if(pFile == NULL) {
				buffer = new Record<ITEM,KEY>[2ULL*FILEINDEX_SORTBUFFERSIZE]; 
				pFile = fopen(filename.c_str(),"w+");
			}
			bufferCount = 0;
			recSize = sizeof(Record<ITEM,KEY>);
			fseek(pFile, 0, SEEK_END);
			fileSize = ftell(pFile)/recSize;

		}
        virtual ~FileIndex(){
            fclose(pFile);
            if(buffer != NULL) delete[] buffer;
        }

		void append(KEY key, ITEM item){
			Record<ITEM,KEY> record;
			record.key = key;
			record.value = item;
			buffer[bufferCount] = record;
			bufferCount ++;
			if (bufferCount == FILEINDEX_SORTBUFFERSIZE) {
				flush();
			}
			
		}

		void appendRaw(KEY key, ITEM item){
			Record<ITEM,KEY> record;
			record.key = key;
			record.value = item;
			buffer[bufferCount] = record;
			bufferCount ++;
			if (bufferCount == FILEINDEX_SORTBUFFERSIZE) {
				fwrite(&buffer[0], recSize, bufferCount, pFile);
				bufferCount = 0;				
			}
			
		}

		void flush(){
			for ( int k = 0; k < fileSize; k+=FILEINDEX_SORTBUFFERSIZE) {
				fseek(pFile, k*recSize, SEEK_SET);
				int count = fread(&buffer[bufferCount], recSize, FILEINDEX_SORTBUFFERSIZE, pFile);
				std::qsort(&buffer[0], bufferCount +  FILEINDEX_SORTBUFFERSIZE,recSize,fileIndexComp<ITEM,KEY>);
				fseek(pFile, k*recSize, SEEK_SET);
				fwrite(&buffer[0], recSize, FILEINDEX_SORTBUFFERSIZE, pFile);
				memcpy(&buffer[0],&buffer[FILEINDEX_SORTBUFFERSIZE],bufferCount*recSize);
			}
			fseek(pFile, 0, SEEK_END);		
			std::qsort(&buffer[0], bufferCount,recSize,fileIndexComp<ITEM,KEY>);
			fwrite(&buffer[0], recSize, bufferCount, pFile);
			bufferCount = 0;
			fseek(pFile, 0, SEEK_END);
			fileSize = ftell(pFile)/recSize;
		}

		bool  getAndCache(size_t pos, Record<ITEM,KEY>* result){
				//std::map<size_t, int>::iterator it;
				auto it = cache.find(pos);
				if(it == cache.end()) {
					if(get(pos, result)) {
						cache[pos] = *result;
						return true;
					} else return false;
				} else {
					*result = it->second;
					return true;
				}			
		}
		
		bool  get(size_t pos, Record<ITEM,KEY>* result ){
			    if( pos >= getSize()) {
					std::cout << "id :" << pos << " " << filename << "not found \n";
					return false;
				} 
				fseek(pFile, pos*recSize, SEEK_SET);
                size_t count = fread(result, recSize, 1, pFile);
                return true;
        }
        
        size_t getSize() {
			return fileSize;
		}
		
	
		bool find(KEY key, Record<ITEM,KEY>* result){
            size_t iMin = 0;
            size_t iMax = getSize() - 1;
            size_t iFound = -1;
            bool found = false;
            short level = 0;

            getAndCache(iMin, result);
            if( result->key == key) {
                return true;
            }
            if( result->key > key) {
                return false;
            }
            getAndCache(iMax, result);
            if( result->key == key) {
                return true;
            }
            if( result->key < key) {
                return false;
            }

            while((iMax - iMin) > 1)
            {
				level++;
                //size_t iPivot = (iMin + (iMax -iMin)/2);
                size_t iPivot = (iMin + iMax) >> 1;
                if(level < FILEINDEX_CACHELEVEL) getAndCache(iPivot,result);
                else get(iPivot, result);
                if(result->key > key) iMax = iPivot;
                else if(result->key == key) {
                    return true;
                }
                else iMin = iPivot;
            }
            return false;
        };

		bool findLastLesser(KEY key, size_t& iMin){
			Record<ITEM,KEY> result;
            iMin = 0;
            size_t iMax = getSize() - 1;
            size_t iFound = -1;
            bool found = false;
			short level = 0;
            getAndCache(iMin, &result);
            if( result.key == key) {
                return true;
            }
            if( result.key > key) {
                return true;
            }

            getAndCache(iMax, &result);
            if( result.key == key) {
                return true;
            }
            if( result.key < key) {
                return true;
            }

            while((iMax - iMin) > 1)
            {
				level++;
                size_t iPivot = (iMin + (iMax -iMin)/2);
                if(level < FILEINDEX_CACHELEVEL) getAndCache(iPivot,&result);
                else get(iPivot, &result);
                if(result.key > key) iMax = iPivot;
                else iMin = iPivot;
            }
            get(iMin, &result);
            while((iMin > 0) && (result.key >= key))
            {
				iMin--;
				get(iMin, &result);
			}
            return true;
        };

};


template<class ITEM> class FileRawIndex {
	private:
		std::string filename;
		FILE * pFile;
		ITEM *buffer;
		unsigned long bufferCount;
		size_t recSize;
		size_t fileSize;
	public:
		unsigned long itemCount;
		FileRawIndex(std::string filename, bool replace) : filename(filename) {
            buffer = new ITEM[1024]; 
            if(!replace)
                pFile = fopen (filename.c_str(),"r+");
            else pFile = NULL;
			if(pFile == NULL) {
				pFile = fopen(filename.c_str(),"w+");
			}
			bufferCount = 0;
			itemCount = 0;
			recSize = sizeof(ITEM);
			fseek(pFile, 0, SEEK_END);
			fileSize = ftell(pFile)/recSize;

		}
        virtual ~FileRawIndex(){
            fclose(pFile);
            delete[] buffer;
        }

		void append(ITEM record){
			buffer[bufferCount] = record;
			bufferCount ++;itemCount++;
			if (bufferCount == 1024) {
				flush();				
			}
			
		}

		void flush(){
				fwrite(&buffer[0], recSize, bufferCount, pFile);
				bufferCount = 0;				
				fileSize = ftell(pFile)/recSize;
		}

		bool  get(size_t pos, ITEM* result ){
			    if( pos >= getSize()) {
					return false;
				} 
				fseek(pFile, pos*recSize, SEEK_SET);
                size_t count = fread(result, recSize, 1, pFile);
                return true;
        }
        
        size_t getSize() {
			return fileSize;
		}
};



}
#endif
