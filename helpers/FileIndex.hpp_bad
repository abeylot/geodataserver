#ifndef FILEINDEX_HPP
#define FILEINDEX_HPP
#ifndef _LARGEFILE64_SOURCE
#define _LARGEFILE64_SOURCE
#endif
#define _FILE_OFFSFET_BITS 64
//#define FILEINDEX_SORTBUFFERSIZE 10000000LL
#define FILEINDEX_RAWFLUSHSIZE   10000ULL
#define FILEINDEX_CACHELEVEL 24
#include <string>
#include <unordered_map>
#include <algorithm>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

// IMPORTANT KEY et ITEM doivent être des types 'triviaux'
// i.e. entier, double, char ou structure et tableaux de ces types.
namespace fidx
{
template <class ITEM,class KEY> struct Record
{
    KEY key;
    ITEM value;
};

// fonction de comparaison
// à spécialiser si l'opérateur de comparaison n'est pas disponible
template <class ITEM, class KEY> int fileIndexComp(const void* a, const void* b)
{
    Record<ITEM,KEY>* ga = (Record<ITEM,KEY>*) a;
    Record<ITEM,KEY>* gb = (Record<ITEM,KEY>*) b;
    if( ga->key < gb->key ) return -1;
    else if( ga->key > gb->key ) return 1;
    return 0;
}


template<class ITEM, class KEY> class FileIndex
{
private:
    std::string filename;
    Record<ITEM, KEY> *buffer;
    unsigned long bufferCount;
    uint64_t recSize;
    uint64_t sortedSize;
    std::unordered_map<uint64_t, Record<ITEM, KEY>> cache;
public:
    uint64_t fileSize;
    int pFile;
    FileIndex(std::string filename_, bool replace) : filename(filename_)
    {
	std::cout << "file name : " << this->filename << ":" << filename << "\n";
        buffer = NULL;
        if(!replace) {
            pFile = open (filename.c_str(), O_RDONLY | O_LARGEFILE);
	    if(pFile < 0) exit(1);
	}
        else pFile = -1;
        if(pFile < 0)
        {
            remove(filename.c_str());
            //buffer = new Record<ITEM,KEY>[2ULL*FILEINDEX_SORTBUFFERSIZE];
            buffer = new Record<ITEM,KEY>[FILEINDEX_RAWFLUSHSIZE];
            pFile = open(filename.c_str(),O_RDWR | O_CREAT | O_LARGEFILE, 0600);
        }
        bufferCount = 0;
        recSize = sizeof(Record<ITEM,KEY>);
        fileSize = lseek64(pFile, 0, SEEK_END)/recSize;
 
    }
    virtual ~FileIndex()
    {
        close(pFile);
        if(buffer != NULL) delete[] buffer;
    }

    void append(KEY key, ITEM item)
    {
        Record<ITEM,KEY> record;
        record.key = key;
        record.value = item;
        buffer[bufferCount] = record;
        bufferCount ++;
        if (bufferCount == FILEINDEX_RAWFLUSHSIZE)
        {
            flush();
        }

    }

    void appendRaw(KEY key, ITEM item)
    {
        Record<ITEM,KEY> record;
        record.key = key;
        record.value = item;
        buffer[bufferCount] = record;
        bufferCount ++;
        if (bufferCount == FILEINDEX_RAWFLUSHSIZE)
        {
            write(pFile, &buffer[0], recSize * bufferCount);
            bufferCount = 0;
        }

    }

    void flush()
    {
        lseek64(pFile, 0, SEEK_END);
        write(pFile, &buffer[0], recSize * bufferCount);
        bufferCount = 0;
        fileSize = lseek64(pFile, 0, SEEK_END)/recSize;
     }

    void swap(uint64_t item1, uint64_t item2)
    {
        Record<ITEM,KEY> rec1, rec2;
        //fseeko(pFile, item1 * recSize, SEEK_SET);
        uint64_t count = pread64(pFile, (char*)&rec1, recSize, item1 * recSize);
        if(count == 0)
        {
            std::cerr << "read error \n";
            return;
        }
        //fseeko(pFile, item2 * recSize, SEEK_SET);
        count = pread64(pFile, (char*)&rec2, recSize, item2*recSize);
        if(count == 0)
        {
            std::cerr << "read error \n";
            return;
        }
        //fseeko(pFile, item1 * recSize, SEEK_SET);
        count = pwrite64(pFile, (char*)&rec2, recSize, item1*recSize);
        if(count == 0)
        {
            std::cerr << "write error \n";
            return;
        }
        //fseeko(pFile, item2 * recSize, SEEK_SET);
        count = pwrite64(pFile, (char*)&rec1, recSize, item2*recSize);
        if(count == 0)
        {
            std::cerr << "write error \n";
            return;
        }

    }

    void sort()
    {
        std::cerr << "sorting  " << fileSize << " elements \n";
        if(!fileSize) return;
        sortedSize = 0;
        uint64_t buffer_size = 100000000ULL;
        Record<ITEM,KEY>* sort_buffer = NULL;
        while(sort_buffer == NULL)
        {
			buffer_size /= 2;
			try
			{
				sort_buffer = new Record<ITEM,KEY>[buffer_size*3];
			} catch(std::bad_alloc& ba)
			{
				std::cout << "buffer_size : " << buffer_size << "too big\n";
			}
		}
        sort(0,fileSize-1, sort_buffer, buffer_size);
        delete[] sort_buffer;
    }
    void sort(uint64_t begin, uint64_t end, Record<ITEM,KEY>* sort_buffer, uint64_t buffer_size)
    {
        std::cerr << "sort " << begin <<" "<< end <<"\n";
        uint64_t count = (end - begin) + 1;
        //coutFile(pFile);
        if((end - begin) < (3ULL*buffer_size))
        {
            std::cout << "enough memory, performing qsort \n";
            //fseeko(pFile, begin * recSize, SEEK_SET);
            count = pread64(pFile, (char*)sort_buffer, recSize * count, begin*recSize) / recSize;
            std::qsort(&sort_buffer[0], count , recSize, fileIndexComp<ITEM,KEY>);
            //fseeko(pFile, begin * recSize, SEEK_SET);
            count = pwrite64(pFile, (char*)sort_buffer, recSize * count, begin*recSize) / recSize;
            sortedSize += count;
            std::cerr << "sorted " << sortedSize << " out of " << fileSize << "\n";
            return;
        }
        //std::cerr << "sort " << begin <<" "<< end <<"\n";
        if((end - begin) > 2)
        {
            uint64_t i = (end + begin) / 2;
            swap(i,end);
        }
        //coutFile(pFile);
        Record<ITEM,KEY>* plusPetits = sort_buffer;
        Record<ITEM,KEY>* plusGrands = sort_buffer + buffer_size;
        Record<ITEM,KEY>* autres = sort_buffer + 2ULL*buffer_size;
        Record<ITEM,KEY> pivot;
        get(end, &pivot);
        uint64_t plusPetitsBufferCount=0;
        uint64_t plusGrandsBufferCount=0;
        uint64_t autresBufferCount=0;
        uint64_t autresCount = end - begin;
        uint64_t plusGrandsCount = 0;
        uint64_t plusPetitsCount = 0;
        while(autresCount > 0)
        {
            uint64_t toRead = buffer_size;
            std::cout << "reading " << toRead << "items from file \n";
            if(toRead > autresCount) toRead = autresCount;
            //fseeko(pFile, (end - (toRead  + plusGrandsCount)) * recSize, SEEK_SET);
            uint64_t count = pread64(pFile, (char*)autres, recSize * toRead, (end - (toRead  + plusGrandsCount)) * recSize) / recSize;
            if(!count)
            {
                std::cerr << "File error 1!\n";
            }
            autresBufferCount = toRead;
            plusPetitsBufferCount = 0;
            plusGrandsBufferCount = 0;
            autresCount -= toRead;
            std::cout << "dividing items \n";
            while(autresBufferCount > 0)
            {
                int comp = fileIndexComp<ITEM,KEY>(&autres[autresBufferCount -1], &pivot);
                if(comp > 0)
                {
                    plusGrands[plusGrandsBufferCount] = autres[autresBufferCount - 1];
                    plusGrandsBufferCount++;
                }
                else
                {
                    plusPetits[plusPetitsBufferCount] = autres[autresBufferCount - 1];
                    plusPetitsBufferCount++;
                }
                autresBufferCount --;
            }
            std::cout << "divided items \n";

            if(plusGrandsBufferCount)
            {
                std::cout << plusGrandsBufferCount << " items where bigger writing them to file\n";
                //fseeko(pFile, (end - (plusGrandsCount + plusGrandsBufferCount - 1)) * recSize, SEEK_SET);
                count = pwrite64(pFile, (char*)plusGrands, recSize * plusGrandsBufferCount, (end - (plusGrandsCount + plusGrandsBufferCount - 1)) * recSize) / recSize;
                if(!count) std::cerr << "File error 2!\n";
            }
            plusGrandsCount += plusGrandsBufferCount;
            std::cout << plusPetitsBufferCount << " items where smaller writing them to file\n";
            if(autresCount  < plusPetitsBufferCount)
            {
                std::cout << " cache " << autresCount << " items \n";
                //fseeko(pFile, (begin + plusPetitsCount) * recSize, SEEK_SET);
                uint64_t count = pread64(pFile, (char*)autres, recSize * autresCount, (begin + plusPetitsCount) * recSize);
                if(plusPetitsBufferCount)
                {
                    std:: cout << "write smallers \n";
                    //fseeko(pFile, (begin + plusPetitsCount) * recSize, SEEK_SET);
                    count = pwrite64(pFile, (char*)plusPetits, recSize * plusPetitsBufferCount, (begin + plusPetitsCount) * recSize) / recSize;
                    if(!count) std::cerr << "File error 3!\n";
                    plusPetitsCount += plusPetitsBufferCount;
                }
                if(autresCount)
                {
                    std:: cout << "write cached \n";
                    //fseeko(pFile, (begin+plusPetitsCount) * recSize, SEEK_SET);
                    count = pwrite64(pFile, (char*)autres, recSize * autresCount, (begin+plusPetitsCount) * recSize)/ recSize;
                    if(!count) std::cerr << "File error 4!\n";
                }

            }
            else
            {
                if(plusPetitsBufferCount)
                {

                    std::cout << " cache " << plusPetitsCount << " items \n";
                    //fseeko(pFile, (begin + plusPetitsCount) * recSize, SEEK_SET);
                    uint64_t count = pread64(pFile, (char*)autres, recSize * plusPetitsBufferCount, (begin + plusPetitsCount) * recSize) / recSize;
                    if(!count) std::cerr << "File error 5!\n";

                    std:: cout << "write smallers \n";
                    //fseeko(pFile, (begin + plusPetitsCount) * recSize, SEEK_SET);
                    count = pwrite64(pFile, (char*)plusPetits, recSize * plusPetitsBufferCount, (begin + plusPetitsCount) * recSize) / recSize;
                    if(!count) std::cerr << "File error 6!\n";

                    plusPetitsCount += plusPetitsBufferCount;

                    std:: cout << "write cached \n";
                    //fseeko(pFile, (end - (plusGrandsCount + plusPetitsBufferCount)) * recSize, SEEK_SET);
                    count = pwrite64(pFile, (char*)autres, recSize * plusPetitsBufferCount, (end - (plusGrandsCount + plusPetitsBufferCount)) * recSize) / recSize;
                    if(!count) std::cerr << "File error 7!\n";
                }
            }
            //xxx
            //fseeko(pFile, (end  - (plusGrandsCount)) * recSize, SEEK_SET);
            std:: cout << "write pivot at the right place \n";
            count = pwrite64(pFile, (char*)&pivot, recSize, (end  - (plusGrandsCount)) * recSize) / recSize;

        }
        if(!count) std::cerr << "File error 8!\n";
        sortedSize++;

        if(plusGrandsCount > 1) sort(end - (plusGrandsCount - 1), end, sort_buffer, buffer_size);
        else if(!plusGrandsCount) sortedSize++;
        if(plusPetitsCount > 1) sort(begin, begin + plusPetitsCount - 1, sort_buffer, buffer_size);
        else if(!plusPetitsCount) sortedSize++;
    }

    bool  getAndCache(uint64_t pos, Record<ITEM,KEY>* result)
    {
        auto it = cache.find(pos);
        if(it == cache.end())
        {
            if(get(pos, result))
            {
                cache[pos] = *result;
                return true;
            }
            else return false;
        }
        else
        {
            *result = it->second;
            return true;
        }
    }

    inline bool  get(uint64_t pos, Record<ITEM,KEY>* result )
    {
        if( pos >= getSize())
        {
            return false;
        }
        //fseeko(pFile, pos*recSize, SEEK_SET);
        uint64_t count = pread64(pFile, result, recSize, pos*recSize) / recSize;
        if(count)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    uint64_t getSize()
    {
        return fileSize;
    }


    bool find(KEY key, Record<ITEM,KEY>* result)
    {
        uint64_t iMin = 0;
        uint64_t iMax = getSize() - 1;
        short level = 0;

        getAndCache(iMin, result);
        if( result->key == key)
        {
            return true;
        }
        if( result->key > key)
        {
            return false;
        }
        getAndCache(iMax, result);
        if( result->key == key)
        {
            return true;
        }
        if( result->key < key)
        {
            return false;
        }

        while((iMax - iMin) > 1)
        {
            level++;
            uint64_t iPivot = (iMin + iMax) >> 1;
            if(level < FILEINDEX_CACHELEVEL) getAndCache(iPivot,result);
            else get(iPivot, result);
            if(result->key > key) iMax = iPivot;
            else if(result->key == key)
            {
                return true;
            }
            else iMin = iPivot;
        }
        return false;
    };

    bool findLastLesser(KEY key, uint64_t& iMin)
    {
        Record<ITEM,KEY> result;
        iMin = 0;
        uint64_t iMax = getSize() - 1;
        //uint64_t iFound = -1;
        //bool found = false;
        short level = 0;
        getAndCache(iMin, &result);
        if( result.key == key)
        {
            return true;
        }
        if( result.key > key)
        {
			iMin = 0;
            return true;
        }

        getAndCache(iMax, &result);
        //if( result.key == key)
        //{
        //    return true;
        //}
        if( result.key < key)
        {
			iMin = iMax;
            return true;
        }

        while((iMax - iMin) > 1)
        {
            level++;
            uint64_t iPivot = (iMin + (iMax -iMin)/2);
            if(level < FILEINDEX_CACHELEVEL) getAndCache(iPivot,&result);
            else get(iPivot, &result);
            if(result.key >= key) iMax = iPivot;
            else iMin = iPivot;
        }
        //get(iMin, &result);
        /*while((iMin > 0) && (result.key >= key))
        {
            iMin--;
            get(iMin, &result);
        }*/
        return true;
    };

};


template<class ITEM> class FileRawIndex
{
private:
    std::string filename;
    int pFile;
    ITEM *buffer;
    unsigned long bufferCount;
    uint64_t recSize;
    uint64_t fileSize;
public:
    unsigned long itemCount;
    FileRawIndex(std::string filename, bool replace) : filename(filename)
    {
        buffer = new ITEM[FILEINDEX_RAWFLUSHSIZE];
        if(!replace)
            pFile = open (filename.c_str(),O_RDONLY | O_LARGEFILE);
        else pFile = -1;
        if(pFile == -1)
        {
            remove(filename.c_str());
            pFile = open(filename.c_str(),O_WRONLY | O_CREAT | O_LARGEFILE, 0600);
        }
        bufferCount = 0;
        itemCount = 0;
        recSize = sizeof(ITEM);
        fileSize = lseek64(pFile, 0, SEEK_END)/recSize;

    }
    virtual ~FileRawIndex()
    {
        close(pFile);
        delete[] buffer;
    }

    void append(ITEM record)
    {
        buffer[bufferCount] = record;
        bufferCount ++;
        itemCount++;
        if (bufferCount == FILEINDEX_RAWFLUSHSIZE)
        {
            flush();
        }

    }

    void flush()
    {
        write(pFile, &buffer[0], recSize * bufferCount);
        bufferCount = 0;
        fileSize = lseek64(pFile, 0, SEEK_END)/recSize;
    }

    bool  get(uint64_t pos, ITEM* result )
    {
        if( pos >= getSize())
        {
            return false;
        }
        //fseeko(pFile, pos*recSize, SEEK_SET);
        uint64_t count = pread(pFile, result, recSize, pos*recSize);
        if(count)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

    uint64_t getSize()
    {
        return fileSize;
    }
};


template<class ITEM> class FileRawData
{
public:
    uint64_t startPos;
    int pFile;
    ITEM* buffer;
    uint64_t bufferCount;
    uint64_t itemCount;
    uint64_t recSize;
    uint64_t fileSize;
    uint64_t startCount;
public:
    FileRawData(std::string filename, bool replace)
    {
        buffer = new ITEM[FILEINDEX_RAWFLUSHSIZE];
        if(!replace)
            pFile = open(filename.c_str(),O_RDONLY | O_LARGEFILE);
        else pFile = -1;
        if(pFile == -1)
        {
           remove(filename.c_str());
           pFile = open(filename.c_str(),O_WRONLY | O_CREAT | O_LARGEFILE, 0600);
        }
        bufferCount = 0;
        itemCount = 0;
        recSize = sizeof(ITEM);
        //fseeko(pFile, 0, SEEK_END);
        fileSize = lseek64(pFile, 0, SEEK_END)/recSize;
    }

    ITEM* getData(uint64_t start, uint64_t count)
    {
        if(count == 0) return NULL;
        ITEM* result = (ITEM*) malloc(sizeof(ITEM)*count);
        //fseeko(pFile, start*recSize, SEEK_SET);
        count = pread64(pFile, result, recSize * count, start*recSize);
        return result;
    }

    void startBatch()
    {
        startCount = itemCount;
    }

    void append(ITEM record)
    {
        buffer[bufferCount] = record;
        bufferCount ++;
        itemCount++;
        if (bufferCount == FILEINDEX_RAWFLUSHSIZE)
        {
            flush();
        }
    }

    void flush()
    {
        write(pFile, &buffer[0], recSize * bufferCount);
        bufferCount = 0;
       fileSize = lseek64(pFile, 0, SEEK_END)/recSize;
     }

    static void revert(ITEM* buf, unsigned int size)
    {
        unsigned int  imax = size / 2;
        ITEM swap;
        for(unsigned int  i = 0 ; i < imax; i++)
        {
            swap = buf[i];
            buf[i] = buf[size - (i+1)];
            buf[size - (i+1)] = swap;
        }
    }

};


template<class ITEM> class FileRawVarData
{
public:
    uint64_t startPos;
    int pFile;
    char* buffer;
    uint64_t bufferCount;
    uint64_t itemCount;
    uint64_t startCount;
public:
    FileRawVarData(std::string filename, bool replace)
    {
        buffer = new char[FILEINDEX_RAWFLUSHSIZE];
        if(!replace)
            pFile = open(filename.c_str(),O_RDONLY | O_LARGEFILE);
        else pFile = -1;
        if(pFile == -1)
        {
            remove(filename.c_str());
            pFile = open(filename.c_str(),O_WRONLY | O_CREAT | O_LARGEFILE, 0600);
        }
        bufferCount = 0;
        itemCount = 0;
        lseek64(pFile, 0, SEEK_END);
        //fseeko(pFile, 0, SEEK_END);
    }

    char* getData(uint64_t start, uint64_t count)
    {
        if(count == 0) return NULL;
        char* result = (char*) malloc(count);
        //fseeko(pFile, start, SEEK_SET);
        count = pread64(pFile, result, count, start);
        return result;
    }

    void startBatch()
    {
        startCount = itemCount;
    }

    void append(ITEM& record)
    {
        unsigned char sz;
        uint64_t size = record.size();
        const char* buff = record.buffer();
        if(size > 255) size = 255;
        sz = size;
        buffer[bufferCount] = ((char)sz);
        bufferCount ++;
        itemCount++;
        memcpy(buffer + bufferCount, buff, sz);
        bufferCount += sz;
        itemCount += sz;
        if (bufferCount >= (FILEINDEX_RAWFLUSHSIZE - 256))
        {
            flush();
        }
    }

    void flush()
    {
        write(pFile, buffer, bufferCount);
        bufferCount = 0;
    }


};



}
#endif
